    
    <!-- DRAWER MARKUP: Place this outside the sticky bar, typically near the bottom of the body -->
<div id="envios-drawer" class="drawer-modal">
  <div class="drawer-modal-content">
    <!-- Close Button -->
    <button class="drawer-close" aria-label="Close">&times;</button>

    <!-- Drawer Body -->
    <div class="drawer-modal-body">

      <!-- MÉTODOS DE ENVIO -->
      <h3>MÉTODOS DE ENVIO</h3>
      <ul>
        <li>Recolha na loja <strong>GRÁTIS</strong>.</li>
        <li>Envio para o ponto de entrega <strong>3,99 €</strong></li>
        <li>Envio normal <strong>4,99 €</strong></li>
        <li>Envio normal (Açores e Madeira) <strong>29,99 €</strong></li>
      </ul>

      <!-- TROCAS E DEVOLUÇÕES -->
      <h3>TROCAS E DEVOLUÇÕES</h3>
      <p>
        Podes devolver um artigo até 30 dias após receberes o e-mail de confirmação de envio da tua encomenda.
      </p>

      <!-- TROCAS -->
      <h3>TROCAS</h3>
      <ul>
        <li>Na loja Lefties – <strong>GRÁTIS</strong></li>
        <li>
          Artigos comprados em Cheyenne.pt podem ser trocados por outros de tamanho ou cor diferentes, em qualquer loja Cheyenne, desde que haja disponibilidade.
        </li>
        <li>
          Também podes efetuar a troca através de Cheyenne.pt. Após a verificação do estado do artigo, enviamos o novo produto de substituição.
        </li>
      </ul>

      <!-- DEVOLUÇÕES -->
      <h3>DEVOLUÇÕES</h3>
      <ul>
        <li>Na loja – <strong>GRÁTIS</strong></li>
        <li>Pela Cheyenne.pt - <strong>1,99 €</strong></li>
        <li>
          Para ver os pontos de entrega disponíveis, clique 
          <a href="#">[AQUI]</a>
        </li>
      </ul>

    </div>
  </div>
</div>


    <div class="mobile-related-products">
      <h2 class="also" style="margin-bottom: 1em;">Talvez lhe possa interessar</h2>
      {% render 'random-collection-grid' %}
    </div>
    <div class="drawer-footer" style="margin-top: 20px;">
      {% render 'footer-drawer' %}
    </div>
  </div>
</div>


<!-- Variant Selection Drawer (separate from sticky content so it always displays) -->
<div id="variant-drawer" class="drawer-modal" style="display: none;">
  <div class="drawer-modal-content">
    <button class="drawer-close" aria-label="Close">&times;</button>
    <div class="drawer-modal-body">
      <h3 style="margin-top:0;">{{ 'products.product.choose_options' | t | default: 'Choose options' }}</h3>
      {% unless product.has_only_default_variant %}
        <div class="drawer-variant-picker">
          {% render 'product-variant-picker', product: product, block: dummy_block, product_form_id: 'drawer-product-form-' | append: section.id %}
        </div>
      {% endunless %}
      <div class="drawer-add-to-cart" style="margin-top: 16px;">
        {% render 'buy-buttons',
            block: dummy_block,
            product: product,
            product_form_id: 'drawer-product-form-' | append: section.id,
            section_id: section.id,
            show_pickup_availability: false
        %}
      </div>
    </div>
  </div>
</div>


<!-- JS for sticky bar drag + momentum + recalc/clamp -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  const stickyBar = document.getElementById('sticky-product-bar');
  
  // Disable default touch actions so pointer events work reliably.
  stickyBar.style.touchAction = 'none';
  
  const minHeight = 195; // Collapsed height
  let maxHeight = stickyBar.scrollHeight; // Current "expanded" height

  let startY = 0;
  let startHeight = 0;
  let dragging = false;
  
  // For velocity-based momentum
  let lastY = 0;
  let lastTime = 0;
  let velocity = 0;

  // ---------- ORIGINAL “SWIPE FEEL” VALUES ----------
  const dragMultiplier = 1.5; // (Reverted to your original value)
  const deceleration = 0.0025; // (Reverted to your original value)

  // --------------------------
  // HELPER: Recalc/Clamp Height
  // --------------------------
  function recalcMaxHeight() {
    const newMaxHeight = stickyBar.scrollHeight;
    const currentHeight = stickyBar.offsetHeight;
    
    maxHeight = newMaxHeight;
    
    // If the bar is now taller than content (e.g. dropdown was closed),
    // clamp it so no blank space remains.
    if (currentHeight > newMaxHeight) {
      stickyBar.style.height = newMaxHeight + 'px';
    } else {
      // If the bar was basically at old max, keep it at new max
      if (Math.abs(currentHeight - maxHeight) < 2) {
        stickyBar.style.height = newMaxHeight + 'px';
      }
    }
  }

  // --------------------------
  // MOMENTUM ANIMATION
  // --------------------------
  function animateMomentum(initialVelocity) {
    let currentHeight = stickyBar.offsetHeight;
    let v = initialVelocity;
    let previousTime = performance.now();
    
    function step(currentTime) {
      const dt = currentTime - previousTime;
      previousTime = currentTime;
      
      currentHeight += v * dt;
      
      // Apply deceleration
      if (v > 0) {
        v -= deceleration * dt;
        if (v < 0) v = 0;
      } else if (v < 0) {
        v += deceleration * dt;
        if (v > 0) v = 0;
      }
      
      // Clamp to min/max
      if (currentHeight < minHeight) {
        currentHeight = minHeight;
        v = 0;
      } else if (currentHeight > maxHeight) {
        currentHeight = maxHeight;
        v = 0;
      }
      
      stickyBar.style.height = currentHeight + 'px';
      
      // Continue if velocity remains
      if (Math.abs(v) > 0.01) {
        requestAnimationFrame(step);
      } else {
        // Snap to nearest if close
        const snapThreshold = 50;
        if (currentHeight - minHeight < snapThreshold) {
          stickyBar.style.height = minHeight + 'px';
        } else if (maxHeight - currentHeight < snapThreshold) {
          stickyBar.style.height = maxHeight + 'px';
        }
      }
    }
    
    requestAnimationFrame(step);
  }
  
  // --------------------------
  // POINTER EVENTS FOR DRAG
  // --------------------------
stickyBar.addEventListener('pointerdown', function(e) {
  // If the click starts on an accordion button or its content, do nothing
  if (e.target.closest('.accordion-button') || e.target.closest('.accordion-content')) {
    return;
  }
  
  // Exclude <select> or custom dropdowns from dragging
 if (e.target.closest('.custom-dropdown')) {
  return;
}
  
  e.preventDefault();
  
  startY = e.clientY;
  startHeight = stickyBar.offsetHeight;
  dragging = true;
  stickyBar.style.transition = 'none';
  stickyBar.setPointerCapture(e.pointerId);
  
  // Initialize velocity tracking
  lastY = e.clientY;
  lastTime = performance.now();
  velocity = 0;

  // Also recalc if content changed
  maxHeight = stickyBar.scrollHeight;
});
  
  stickyBar.addEventListener('pointermove', function(e) {
    if (!dragging) return;
    
    const now = performance.now();
    const dt = now - lastTime;
    
    if (dt > 0) {
      velocity = ((lastY - e.clientY) * dragMultiplier) / dt;
    }
    lastY = e.clientY;
    lastTime = now;
    
    const deltaY = (startY - e.clientY) * dragMultiplier;
    let newHeight = startHeight + deltaY;
    
    // Clamp to min/max
    newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
    stickyBar.style.height = newHeight + 'px';
  });
  
  stickyBar.addEventListener('pointerup', function(e) {
    if (!dragging) return;
    dragging = false;
    stickyBar.releasePointerCapture(e.pointerId);
    
    // If velocity is significant, fling
    if (Math.abs(velocity) > 0.1) {
      animateMomentum(velocity);
    } else {
      // Snap to min or max if close
      const currentHeight = stickyBar.offsetHeight;
      const snapThreshold = 50;
      if (currentHeight - minHeight < snapThreshold) {
        stickyBar.style.height = minHeight + 'px';
      } else if (maxHeight - currentHeight < snapThreshold) {
        stickyBar.style.height = maxHeight + 'px';
      }
    }
  });
  
  // Prevent pointer events from interfering with <select> usage
  document.querySelectorAll('select').forEach(function(selectEl) {
    selectEl.addEventListener('pointerdown', function(e) {
      e.stopPropagation();
    });
  });

  // --------------------------
  // LISTEN FOR SUBMENU OPEN/CLOSE
  // --------------------------
  // We'll re-measure the bar after each toggle,
  // to clamp or expand as needed.
  const dropdownLinks = document.querySelectorAll('.mobile-menu .has-submenu > a.menu-link');
  dropdownLinks.forEach(link => {
    link.addEventListener('click', function() {
      // Let your existing code open/close the dropdown,
      // then recalc/clamp after a short delay
      setTimeout(() => {
        recalcMaxHeight();
      }, 300);
    });
  });
});
</script>


<!-- Variant ID Sync Script -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  if (typeof productData === 'undefined' || !productData.variants) {
    console.warn("productData not found or has no variants");
    return;
  }
  
  const buyButtonsForm = document.querySelector('#sticky-product-bar .add-to-cart form');
  if (!buyButtonsForm) {
    console.warn("No buy-buttons form found within .add-to-cart");
    return;
  }
  
  const hiddenInput = buyButtonsForm.querySelector('input[name="id"]');
  if (!hiddenInput) {
    console.warn("No hidden input[name='id'] found in buy-buttons form");
    return;
  }
  
  const variantPickerEl = document.getElementById('variant-selects-{{ section.id }}');
  if (!variantPickerEl) {
    console.warn("No variant-picker element found with id: variant-selects-{{ section.id }}");
    return;
  }
  
  const optionInputs = variantPickerEl.querySelectorAll('input[name^="options"], select[name^="options"]');
  if (!optionInputs.length) {
    console.warn("No variant option inputs found in variant-picker");
    return;
  }

  function getSelectedOptions() {
    const selected = [];
    optionInputs.forEach(input => {
      if (input.tagName.toLowerCase() === 'select' && input.value === "") {
        selected.push(null);
      } else {
        selected.push(input.value.trim());
      }
    });
    return selected;
  }

  function findVariant(selectedOptions) {
    return productData.variants.find(variant => {
      return variant.options.every((opt, idx) => {
        return String(selectedOptions[idx]).toLowerCase() === String(opt).toLowerCase();
      });
    });
  }

  function updateVariant() {
    const selectedOptions = getSelectedOptions();
    const matchingVariant = findVariant(selectedOptions);
    if (matchingVariant) {
      hiddenInput.value = matchingVariant.id;
      hiddenInput.dispatchEvent(new Event('change', { bubbles: true }));
